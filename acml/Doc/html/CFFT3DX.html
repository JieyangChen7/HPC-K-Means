<html lang="en">
<head>
<title>CFFT3DX - AMD Core Math Library (ACML) 5.3.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="AMD Core Math Library (ACML) 5.3.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="3D-FFT.html#g_t3D-FFT" title="3D FFT">
<link rel="prev" href="ZFFT3DX.html#ZFFT3DX" title="ZFFT3DX">
<link rel="next" href="ZFFT3DY.html#ZFFT3DY" title="ZFFT3DY">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="CFFT3DX"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="ZFFT3DY.html#ZFFT3DY">ZFFT3DY</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="ZFFT3DX.html#ZFFT3DX">ZFFT3DX</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="3D-FFT.html#g_t3D-FFT">3D FFT</a>
<hr>
</div>

<h5 class="unnumberedsubsubsec"><code>CFFT3DX</code> Routine Documentation</h5>

<div class="defun">
&mdash; SUBROUTINE: <b>CFFT3DX</b> (<var>MODE,SCALE,LTRANS,INPL,L,M,N,X,Y,COMM,INFO</var>)<var><a name="index-CFFT3DX-221"></a></var><br>
<blockquote><div class="defun">
&mdash; Input: INTEGER <b>MODE</b><var><a name="index-MODE-222"></a></var><br>
<blockquote> <p>The value of <var>MODE</var> on input determines the operation performed by
<code>CFFT3DX</code>. 
<br>
On input:
               <ul>
<li><var>MODE</var>=0 : only initializations (specific to the values of
  <var>L</var>, <var>M</var> and <var>N</var>) are performed using a default plan;
  this is usually followed by calls to the same routine with
  <var>MODE</var>=-1 or 1. 
<li><var>MODE</var>=-1 : a forward 3D transform is performed. 
  Initializations are assumed to have been performed by a prior call
  to <code>CFFT3DX</code>. 
<li><var>MODE</var>=1 : a backward (reverse) 3D transform is performed. 
  Initializations are assumed to have been performed by a prior call
  to <code>CFFT3DX</code>. 
<li><var>MODE</var>=100 : similar to <var>MODE</var>=0; only initializations
  (specific to the values of <var>L</var>, <var>M</var> and <var>M</var>) are
  performed, but these
  are based on a plan that is first generated by timing a subset of all
  possible plans and choosing the quickest (i.e. the FFT computation was
  timed as fastest based on the chosen plan). The plan generation phase
  may take a significant amount of time depending on the values of
  <var>L</var>, <var>M</var> and <var>N</var>. 
</ul>
             </p></blockquote></div>

     <div class="defun">
&mdash; Input: REAL <b>SCALE</b><var><a name="index-SCALE-223"></a></var><br>
<blockquote> <p>On input: <var>SCALE</var> is the scaling factor to apply to the output sequences
</p></blockquote></div>

     <div class="defun">
&mdash; Input: LOGICAL <b>LTRANS</b><var><a name="index-LTRANS-224"></a></var><br>
<blockquote> <p>On input: if <var>LTRANS</var> is .TRUE. then a normal final transposition
is performed internally to return transformed data using the same
storage format as the input data. If <var>LTRANS</var> is .FALSE. then the
final transposition is not performed and transformed data is stored,
in <var>X</var> or <var>Y</var>, in transposed form. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input: LOGICAL <b>INPL</b><var><a name="index-INPL-225"></a></var><br>
<blockquote> <p>On input: if <var>INPL</var> is .TRUE. then <var>X</var> is overwritten by the
output sequences; otherwise the output sequences are returned in
<var>Y</var>. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input: INTEGER <b>L</b><var><a name="index-L-226"></a></var><br>
<blockquote> <p>On input: <var>L</var> is the first dimension of the 3D transform. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input: INTEGER <b>M</b><var><a name="index-M-227"></a></var><br>
<blockquote> <p>On input: <var>M</var> is the second dimension of the 3D transform. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input: INTEGER <b>N</b><var><a name="index-N-228"></a></var><br>
<blockquote> <p>On input: <var>N</var> is the third dimension of the 3D transform. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input/Output: COMPLEX <b>X</b>(<var>L*M*N</var>)<var><a name="index-X-229"></a></var><br>
<blockquote> <p>On input: <var>X</var> contains the <var>L</var> by <var>M</var> by <var>N</var> complex
3D data array to be transformed; the (ijk)th element is stored in
X(i+(j-1)*L+(k-1)*L*M).<br>
On output: if <var>INPL</var> is .TRUE. then <var>X</var> contains the
transformed data, either in the same locations as on input when
<var>LTRANS</var>=.TRUE.; or in locations X(k+(j-1)*N+(i-1)*N*M) when
<var>LTRANS</var>=.FALSE. If <var>INPL</var> is .FALSE. <var>X</var> remains
unchanged. 
</p></blockquote></div>

     <div class="defun">
&mdash; Output: COMPLEX <b>Y</b>(<var>L*M*N</var>)<var><a name="index-Y-230"></a></var><br>
<blockquote> <p>On output: if <var>INPL</var> is .FALSE. then <var>Y</var> contains the
three-dimensional transformed data. If <var>LTRANS</var>=.TRUE. then the
(ijk)th data element is stored in Y(i+(j-1)*L+(k-1)*L*M); otherwise,
the (ijk)th data element is stored in Y(k+(j-1)*N+(k-1)*N*M). If
<var>INPL</var> is .TRUE. then <var>Y</var> is not referenced. 
</p></blockquote></div>

     <div class="defun">
&mdash; Input/Output: COMPLEX <b>COMM</b>(<var>*</var>)<var><a name="index-COMM-231"></a></var><br>
<blockquote> <p><var>COMM</var> is a communication array. Some portions of the array are used to store
initializations for subsequent calls with the same sequence dimensions. 
The remainder is used as temporary store. The amount of store required depends on
the values of the arguments <var>L</var>, <var>M</var>, <var>N</var> and <var>LTRANS</var>. 
If <var>LTRANS</var>=.TRUE. then for a genuine 3D transform (all of <var>L</var>, <var>M</var>, <var>N</var>
greater than 1) the dimension of <var>COMM</var> need only be 5*(L+M+N) + 150;
in this case some further workspace will be allocated internally; the amount of
allocated memory requested will be MAX(L*N+N, L*M + L + M, N). 
If <var>LTRANS</var>=.FALSE. then for a genuine 3D transform the workspace requirement is
considerably more to allow for the storage of an intermediate 3D transposed array;
in this case the dimension of <var>COMM</var> must be at least L*M*N+5*(L+M+N)+150. 
It is recommended that the appropriate 1D or 2D FFT routine be called when at least
one of <var>L</var>, <var>M</var> or <var>N</var> is 1. 
</p></blockquote></div>

     <div class="defun">
&mdash; Output: INTEGER <b>INFO</b><var><a name="index-INFO-232"></a></var><br>
<blockquote> <p>On output: <var>INFO</var> is an error indicator. On successful exit, <var>INFO</var>
contains 0. If <var>INFO</var> = -i on exit, the i-th argument had an illegal
value. 
</p></blockquote></div>

     </blockquote></div>
   Example:
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="example">     C     Forward 3D FFT is performed unscaled, without final transpose
     C     and out-of-place on data stored in array X and output to Y.
     C     Manipulations are stored in vector Y which is then transformed
     C     back, with scaling, into the first M rows of X.
     C
             SCALE = 1.0
             INPL = .FALSE.
             LTRANS = .FALSE.
             CALL CFFT3DX(0,SCALE,LTRANS,INPL,L,M,N,X,Y,COMM,INFO)
             CALL CFFT3DX(-1,SCALE,LTRANS,INPL,L,M,N,X,Y,COMM,INFO)
             IY = 1
             DO 20 I = 1, L
                DO 40 J = 1, M
                   DO 10 K = 1, N
                      Y(IY) = Y(IY)*EXP(-0.001*REAL(I+J+K-3))
                      IY = IY + 1
        10      CONTINUE
        20   CONTINUE
             SCALE = 1.0/REAL(L*M*N)
             CALL CFFT3DX(1,SCALE,LTRANS,INPL,N,M,L,Y,X,COMM,INFO)
</pre>
   </td></tr></table>

   </body></html>

